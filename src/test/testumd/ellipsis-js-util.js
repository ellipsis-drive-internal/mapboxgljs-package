!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.EllipsisUtil=e():t.EllipsisUtil=e()}(self,(function(){return(()=>{"use strict";var t={d:(e,i)=>{for(var o in i)t.o(i,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:i[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{EllipsisApi:()=>r,RasterLayerUtil:()=>o,VectorLayerUtil:()=>i});var i={};t.r(i),t.d(i,{EllipsisVectorLayerBase:()=>d,defaultStyle:()=>c,extractStyling:()=>f,getFeatureStyling:()=>y,getStyleKeys:()=>u,parseHex:()=>g});var o={};t.r(o),t.d(o,{getLayerId:()=>S,getSlippyMapUrl:()=>m});let a="https://api.ellipsis-drive.com/v1";function s(t,e){const i=Error.call(this,e);this.name="API Error",this.message=i.message,this.stack=i.stack,this.status=t}async function n(t,e,i,o){let n={},r="";n["Content-Type"]="application/json",o&&(n.Authorization=`Bearer ${o.token}`,o.mapId&&(r=`?mapId=${o.mapId}`)),e=`${a}${e}${r}`;let l=null,d=!1,h=!1,c={method:t,headers:n};return i&&(c.body=JSON.stringify(i)),await fetch(e,c).then((t=>{t.ok||429===t.status&&alert("You made too many calls to this map and won't be able to use it for another minute. Contact the owner of this map to give you more bandwidth."),l=t;let e=t.headers.get("Content-Type");return e?(d=e.includes("text"),h=e.includes("application/json")):d=!0,h?t.json():d?t.text():t.blob()})).then((t=>{if(200===l.status)return t;throw new s(l.status,d?t:t.message)}))}const r={setApiUrl:t=>a=t,apiUrl:a,getApiUrl:()=>a,post:(t,e,i)=>n("POST",t,e,i),login:(t,e)=>n("POST","/account/login",{username:t,password:e}),getInfo:(t,e)=>n("POST","/info",{pathId:t},e),getMetadata:(t,e,i)=>{let o;return o=e?{mapId:t,includeDeleted:e}:{mapId:t},n("POST","/metadata",o,i)}};class l{static defaultOptions={centerPoints:!1,pageSize:50,maxMbPerTile:16,maxTilesInCache:500,maxFeaturesPerTile:500,useMarkers:!1,loadAll:!1,fetchInterval:0};static optionModifiers={pageSize:t=>Math.min(3e3,t),maxMbPerTile:t=>1e6*t,debug:t=>t?t=>console.log(t):()=>{}};loadingState={loadInterrupters:[],loadingTimeout:void 0,cache:[],nextPageStart:void 0,isLoading:!1,updateLock:!1,missedCall:!1};info={layerInfo:void 0,style:void 0};tiles=[];zoom=1;loadOptions={styleKeys:void 0,onEachFeature:void 0};getMapBounds=()=>console.error("get map bounds not implemented");updateView=()=>console.error("update view not implemented");constructor(t={}){t.blockId?t.layerId?(Object.keys(l.defaultOptions).forEach((e=>{null==t[e]&&(t[e]=l.defaultOptions[e])})),Object.keys(l.optionModifiers).forEach((e=>t[e]=l.optionModifiers[e](t[e]))),this.options={},Object.keys(t).forEach((e=>this.options[e]=t[e])),this.id=`${this.options.blockId}_${this.options.layerId}`):console.error("no layer id specified"):console.error("no block id specified")}getFeatures=()=>{let t;return t=this.options.loadAll?this.loadingState.cache:this.tiles.flatMap((t=>{const e=this.loadingState.cache[this.getTileId(t)];return e?e.elements:[]})),t};clearLayer=async()=>{await this.awaitNotLoading(),this.loadingState.cache=[],this.loadingState.nextPageStart=void 0};update=async()=>{if(this.loadingState.updateLock)return;this.options.debug("update.."),this.info.layerInfo||(this.loadingState.updateLock=!0,await this.fetchLayerInfo(),this.fetchStylingInfo(),this.loadingState.updateLock=!1,this.options.debug("fetched layer info:"),this.options.debug(this.info.layerInfo),this.options.debug("fetched style info:"),this.options.debug(this.info.style));const t=this.getMapBounds();if(!t)return;const e=void 0===this.options.maxZoom?this.info.layerInfo.zoom:this.options.maxZoom;this.zoom=Math.max(Math.min(e,t.zoom-2),0),this.tiles=this.boundsToTiles(t.bounds,this.zoom),this.load(this.updateView,this.options.fetchInterval)};load=async(t,e)=>{if(this.loadingState.loadingTimeout)return;if(this.loadingState.isLoading)return void(this.loadingState.missedCall=!0);this.loadingState.missedCall=!1,this.options.debug("load"),this.loadingState.isLoading=!0;const i=this.options.loadAll?await this.requestAllGeoJsons():await this.requestTileGeoJsons();if(this.loadingState.isLoading=!1,this.loadingState.loadInterrupters.length)return this.loadingState.loadingTimeout=void 0,this.loadingState.loadInterrupters.forEach((t=>t())),void(this.loadingState.loadInterrupters=[]);i||this.loadingState.missedCall?(this.options.debug("loaded new data, page start: "+this.loadingState.nextPageStart),t(),this.loadingState.loadingTimeout=setTimeout((()=>{this.loadingState.loadingTimeout=void 0,this.load(t,e)}),e)):this.options.debug("did not cache new data")};awaitNotLoading=t=>new Promise(((e,i)=>this.loadingState.loadingTimeout||this.loadingState.isLoading?this.loadingState.isLoading?this.loadingState.loadInterrupters.push((()=>e())):this.loadingState.loadingTimeout?(clearTimeout(this.loadingState.loadingTimeout),this.loadingState.loadingTimeout=void 0,t?e():setTimeout((()=>e()),this.options.fetchInterval)):void i():e()));ensureMaxCacheSize=()=>{const t=Object.keys(this.loadingState.cache);if(t.length>this.options.maxTilesInCache){const e=t.map((t=>this.loadingState.cache[t].date)).sort()[9];t.forEach((t=>{this.loadingState.cache[t].date<=e&&delete this.loadingState.cache[t]}))}};requestAllGeoJsons=async()=>{if(4===this.loadingState.nextPageStart)return!1;const t={pageStart:this.loadingState.nextPageStart,mapId:this.options.blockId,returnType:this.options.centerPoints?"center":"geometry",layerId:this.options.layerId,zip:!0,pageSize:Math.min(3e3,this.options.pageSize),styleId:this.options.styleId,style:this.options.style};try{const e=await r.post("/geometry/get",t,{token:this.options.token});this.loadingState.nextPageStart=e.nextPageStart,e.nextPageStart||(this.loadingState.nextPageStart=4),e.result&&e.result.features&&e.result.features.forEach((t=>{this.compileStyle(t),this.loadOptions.onEachFeature&&this.loadOptions.onEachFeature(t),this.loadingState.cache.push(t)}))}catch(t){return console.error("an error occured with getting all features"),console.error(t),!1}return!0};requestTileGeoJsons=async()=>{const t=Date.now(),e=this.tiles.map((t=>{const e=this.getTileId(t);if(!this.loadingState.cache[e])return{tileId:t};const i=this.loadingState.cache[e].nextPageStart;return i&&this.loadingState.cache[e].amount<=this.options.maxFeaturesPerTile&&this.loadingState.cache[e].size<=this.options.maxMbPerTile?{tileId:t,pageStart:i}:null})).filter((t=>t));if(0===e.length)return!1;const i={mapId:this.options.blockId,returnType:this.options.centerPoints?"center":"geometry",layerId:this.options.layerId,zip:!0,pageSize:this.options.pageSize,styleId:this.options.styleId,style:this.options.style,propertyFilter:this.options.filter&&this.options.filter>0?this.options.filter:null};let o=[];for(let t=0;t<e.length;t+=10){i.tiles=e.slice(t,t+10);try{const t=await r.post("/geometry/tile",i,{token:this.options.token});o=o.concat(t)}catch(t){return console.error("an error occured with getting tile features"),console.error(t),!1}}for(let i=0;i<e.length;i++){const a=this.getTileId(e[i].tileId);this.loadingState.cache[a]||(this.loadingState.cache[a]={size:0,amount:0,elements:[],nextPageStart:null});const s=this.loadingState.cache[a];s.date=t,s.size=s.size+o[i].size,s.amount=s.amount+o[i].result.features.length,s.nextPageStart=o[i].nextPageStart,o[i].result.features&&o[i].result.features.forEach((t=>{this.compileStyle(t),this.loadOptions.onEachFeature&&this.loadOptions.onEachFeature(t)})),s.elements=s.elements.concat(o[i].result.features)}return!0};fetchLayerInfo=async()=>{try{const t=await r.getInfo(this.options.blockId,{token:this.options.token});if(!t.geometryLayers)throw new Error("no geometrylayers present in info");const e=t.geometryLayers.find((t=>t.id===this.options.layerId));if(!e)throw new Error("could not find layer in info");this.info.layerInfo=e}catch(t){console.error("error in fetching layer info: "+t.message)}};fetchStylingInfo=()=>{const t=u({blacklist:["radius"]});if(!this.options.styleId&&this.options.style)return void(this.info.style=this.options.style?f(this.options.style.parameters,t):void 0);if(!this.info.layerInfo||!this.info.layerInfo.styles)return void(this.info.style=void 0);const e=this.info.layerInfo.styles.find((t=>t.id===this.options.styleId||t.isDefault&&!this.options.styleId));this.info.style=e&&e.parameters?f(e.parameters,t):void 0};recompileStyles=()=>{this.getFeatures().forEach((t=>this.compileStyle(t)))};compileStyle=t=>{let e=y(t,this.info.style,this.options);e=f(e,this.loadOptions.styleKeys),t.properties||(t.properties={}),t.properties.compiledStyle=e};getTileId=t=>`${t.zoom}_${t.tileX}_${t.tileY}`;boundsToTiles=(t,e)=>{const i=Math.max(t.xMin,-180),o=Math.min(t.xMax,180),a=Math.max(t.yMin,-85),s=Math.min(t.yMax,85),n=Math.pow(2,e),r=n/360,l=Math.PI,d=2*l,h=l/4,c=Math.floor((i+180)*r),p=Math.floor((o+180)*r),u=Math.floor(n/d*(l-Math.log(Math.tan(h+s/360*l)))),g=Math.floor(n/d*(l-Math.log(Math.tan(h+a/360*l))));let f=[];for(let t=Math.max(0,c-1);t<=Math.min(2**e-1,p+1);t++)for(let i=Math.max(0,u-1);i<=Math.min(2**e-1,g+1);i++)f.push({zoom:e,tileX:t,tileY:i});return f}}const d=l,h=(...t)=>{let e=t[t.length-2],i=t[t.length-1];void 0===e&&(e={}),void 0===i&&(i={});const o=Object.fromEntries(Object.keys({...e,...i}).map((t=>[t,void 0===i[t]?e[t]:i[t]])));return t.length>2?h(...t.slice(0,t.length-2),o):o},c={radius:6,width:2,borderColor:"#000000",borderOpacity:1,fillColor:"#000000",fillOpacity:.5},p={radius:[],width:["lineWidth","weight"],borderColor:[],borderOpacity:[],fillColor:["color"],fillOpacity:["opacity"]},u=(t={blacklist:[]})=>Object.fromEntries(Object.entries(p).filter((([e])=>!(t.blacklist.includes(e)||t.whitelist&&!t.whitelist.includes(e))))),g=(t,e)=>{if(!t)return;const i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(t);let[o,a,s,n]=i.slice(1).map((t=>parseInt(t,16)));return n=isNaN(n)?n=void 0:n/=255,e?{r:o,g:a,b:s,opacity:1-n}:{color:`#${i.slice(1,4).join("")}`,opacity:1-n}},f=(t={},e=p)=>{const i={};return Object.entries(t).forEach((([t,o])=>{const a=Object.entries(e).filter((([e,i])=>e===t||i&&i.includes(t)));a&&a.length&&a.forEach((([t])=>i[t]=o))})),i},y=(t,...e)=>{const i=t&&t.properties?f(t.properties):void 0;let o=h(i,...e.map((t=>t?f(t):void 0))),a=g(o.borderColor),s=g(o.fillColor);return a&&!s&&(s={...a},a.opacity=1),!a&&s&&(a={...s},a.opacity=1),a&&(o=h({fillOpacity:s.opacity,borderOpacity:a.opacity},o,{fillColor:s.color,borderColor:a.color})),h(c,o)},m=(t={})=>{if(t.visualization){let e=`${r.getApiUrl()}/settings/mapLayers/preview/${t.blockId}/${t.captureId}/${t.visualization.method}/{z}/{x}/{y}?parameters=${JSON.stringify(t.visualization.parameters)}`;return t.token&&(e+="&token="+t.token),e}let e=`${r.getApiUrl()}/tileService/${t.blockId}/${t.captureId}/${t.visualizationId}/{z}/{x}/{y}`;return t.token&&(e+="?token="+t.token),e},S=(t={})=>`${t.blockId}_${t.captureId}_${t.visualizationId}_${t.visualization?JSON.stringify(t.visualization):"novis"}`;return e})()}));